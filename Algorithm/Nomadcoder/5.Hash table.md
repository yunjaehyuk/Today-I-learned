## 4. Big O

**시간 복잡도를 고려한다는 것은**

입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가이다.

선형검색의 시간 복잡도 = O(N)

**O(1)**
 입력값에 상관없이 일정한 실행시간을 최고!의 알고리즘이라 할 수 있다. 하지만 상수 시간에 실행된다 해도 상수값이 상상 이상으로 클 경우 사실상 일정한 시간의 의미가 없다. 최고의 알고리즘이 될 수 있지만 그만큼 신중해야 한다. 인풋 사이즈와 관계없이, 스텝이 정해진 알고리즘이다.

```python
def print_first(arr):
    print(arr[0])
```

**O(N)**
입력값만큼 실행시간에 영향을 받으며, 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형시간 알고리즘이라고 한다. 정렬되지 않은 리스트에서 최대값 또는 최솟값을 찾는 경우가 이에 해당하며 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴봐야한다.

```python
def print_all(arr):
    for n in arr:
        print(n)
```

**O(log n)**
 로그는 매우 큰 입력값에서도 크게 영향을 받지 않는 편이다. 매우 견고한 알고리즘으로 이진 탐색의 경우가 이에 해당한다. 이진검색과 관련이 있다.

**O (n log n)**
 병합 정렬등의 대부분 효율이 좋은 알고리즘이 이에 해당 한다. 아무리 좋은 알고리즘이라 할지라도 n log n 보다 빠를 수 없다. 입력값이 최선일 경우, 비교를 건너 뛰어 O(n)이 될 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/001b6bfe-6c39-48f9-93b3-8e9aab33e4c1/Untitled.png)

빅오 표기법은 시간 복잡도 외에도 공간 복잡도를 표현하는데 널리 쓰인다. 인풋과 스텝의 상관관계에 집중하기 떄문에 상수를 신경쓰지 않는다. 알고리즘을 설명한다.

알고리즘은  **"시간과 공간이 트레이드오프 관계이다"** (트레이드 오프 : 하나가 증가하면 다른 하나는 감소한다.)

즉, 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다는 것이다

## 4정렬 알고리즘

**sorting** 

뭔가를 정리하는 것(ex 큰 수에서 작은 수로 정렬)
 

**Bubble Sort(버블 정렬)**

버블 정렬은 매번 연속된 두개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법이다.

오름차순으로 정렬하고자 할 경우, 비교시마다 큰 값이 뒤로 이동하여, 1바퀴 돌시 가장 큰 값이 맨 뒤에 저장된다.

로직

1.삽입 정렬은 두 번쨰 인덱스부터 시작한다. 현재 인덱스 값과, 바로 이전의 인덱스 값을 비교한다.

2.만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.

3.현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.

4.이를 반복한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b8f83d3-3ead-443c-9832-f64a58594dc6/Untitled.png)

 시간복잡도 

 O(n^2)

큰 값이 계속 오른쪽으로 이동한다.

**장점** 

구현이 간단하다.

데이터를 하나씩 비교하기 떄문에 정밀한 비교가 가능하다.

**단점**

데이터를 하나씩 비교하기 때문에 비교 횟수가 많아지므로 시간이 오래 걸린다.

**Selection Sort(선택 정렬)**

현재 위치에 들어갈 값을 찾아 정렬하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 딸 최소 선택 정렬와 최대 선택 정려로 구분할 수 있다.최소 선택 정렬은 오름차순으로, 최대 선택 정렬은 내림차수능로 정렬될 것이다.

기본로직 

1.정렬 되지 않은 인덱스의 맨 앞에서 부터 배열값 중 가장 작은 값을 찾아간다.

2.가장 작은 값을 찾으면 그 값을 현재 인덱스의 값과 바꾸준다.

3.다음 인덱스에서 이 과정을 반복한다.

시간복잡도 

 O(n^2)

**👍  장점**

입력으로 들어오는 배열의 원소가 정렬되어있을수록 속도가 빠르다.

정렬된 값은 교환이 일어나지 않는다.

**👎  단점**

▶️ 삽입을 구현해야 하므로 속도가 자료구조의 영향을 많이 받는다.

▶️ 입력으로 들어오는 배열이 역순으로 정렬된 경우 성능이 굉장히 좋지 않다.

**Insertion Sort(삽입 정렬)**

삽입 정렬은 현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 그 위치에 삽입하는 배열 알고리즘이다.

Insertion Sort는 **2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입**
 하여 정렬하는 알고리즘이다.

다음에는 3번쨰 원소부터 사이클이 돌아간다.

시간복잡도 

 O(n^2)

정렬 알고리즘 

삽입,선택 정렬은 작은 DB기준으로 훌륭한 알고리즘이다.
