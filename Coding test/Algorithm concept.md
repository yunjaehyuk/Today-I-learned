## 1.알고리즘을 공부해야하는 가?

**알고리즘**

여러개의 지시사항

내 웹사이트의 속도가 느릴떄 사용한다.

**데이터 구조**

데이터를 어떻게 정리하는 가

어떠한 상황에 어떤 데이터 구조를 써야하는가

1.읽기

2.검색

3.쓰기

4.삭제

## 2.Array

**시간복잡도**

데이터 구조의 오퍼레이션 혹은 알고리즘이 얼마나 빠르고 느린지 측정하는 방법(얼마나 많은 “단계”가 있는가로 측정한다.) 

메모리

데이터를 넣은 박스 같은 것

**비휘발성 메모리**

하드 드라이브

**휘발성 메모리** 

RAM(Random Access Memory)

## Operation

### **1.Reading**

배열은 0부터 인덱싱을 한다.

많은 자료를 읽어야할 떄 랜덤으로 접속이 가능하기 떄문에 배열이 짱이다.

컴퓨터는 배열이 어디서 시작하는지 알고 있다.

배열에서 인덱스에서 요소를 읽어내는 속도는 동일하다.

### 2.Searching

해당 값이 배열에 있는지 없는지 모른다.

일일히 찾아봐야한다.

속도가 빠르지 않다.

**Linear Search(선형 검색)**

순서대로 0부터 끝까지 차근차근 찾는 것

### 3.Insert 혹은 배열에 쓰기

배열에 요소를 추가한다.

중간일 수도 있고, 맨 마지막일 수도 있다.

공간이 부족할 수도 있다.

### 4.Delete

 맨 앞의 값을 없애면 뒤에 있는 값들이 하나씩 앞자리로 움직여야한다.

배열의 마지막에서 작성하는 것이 가장 빠르다.

1. 배열은 연결된 메모리 공간을 사용함.
2. 따라서, 배열은 빈칸이 없도록 데이터를 유지해야 .
3. 따라서, 연결된 순서값인 index를 가지고 특정위치값을 읽는 'Read'는 쉽지만, 무엇이 들었는지 모르는 중에서 찾아야 하는 'Search'와 공간을 옮겨갸 하는 'Add', 'Delete'는 시간이 많이 걸림.

## 3.검색 알고리즘

### Binary Search(이진검색 알고리즘)

Sorted Array(정렬된 배열)에서만 사용가능하다.

이진검색은 중간에서부터 시작한다.

중간에 있는 숫자가 목표 숫자보다 큰지 작은지를 본다.

스텝마다 절반의 아이템을 없앤다.

**이진**

반으로 쪼개는 것을 의미한다.

**Sorted Array**

배열이 순서대로 정렬된 것을 말한다.

순서대로 정렬된 배열에 아이템을 추가하는 것은 순서대로 정렬되지 않은 배열에 아이템을 추가하는 것보다 시간이 많이 든다.반대로 검색하는 것은 더 빠르다.

### Linear Search(선형검색 알고리즘)

처음부터 끝까지 차근차근 찾는 방법

**Linear Time Complexity(선형 시간복잡도)**

인풋이 많을수록 수행하는 시간 역시 선형적으로 증가한다는 것

### Sorting(정렬 알고리즘)

자료를 정리한다.

 

정리

이진검색은 거대한 배열을 다룰 떄 효율적이다.

## 4. Big O
**시간 복잡도를 고려한다는 것은**

입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가이다.

선형검색의 시간 복잡도 = O(N)

**O(1)**
 입력값에 상관없이 일정한 실행시간을 최고!의 알고리즘이라 할 수 있다. 하지만 상수 시간에 실행된다 해도 상수값이 상상 이상으로 클 경우 사실상 일정한 시간의 의미가 없다. 최고의 알고리즘이 될 수 있지만 그만큼 신중해야 한다. 인풋 사이즈와 관계없이, 스텝이 정해진 알고리즘이다.

```python
def print_first(arr):
    print(arr[0])
```

**O(N)**
입력값만큼 실행시간에 영향을 받으며, 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형시간 알고리즘이라고 한다. 정렬되지 않은 리스트에서 최대값 또는 최솟값을 찾는 경우가 이에 해당하며 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴봐야한다.

```python
def print_all(arr):
    for n in arr:
        print(n)
```

**O(log n)**
 로그는 매우 큰 입력값에서도 크게 영향을 받지 않는 편이다. 매우 견고한 알고리즘으로 이진 탐색의 경우가 이에 해당한다. 이진검색과 관련이 있다.

**O (n log n)**
 병합 정렬등의 대부분 효율이 좋은 알고리즘이 이에 해당 한다. 아무리 좋은 알고리즘이라 할지라도 n log n 보다 빠를 수 없다. 입력값이 최선일 경우, 비교를 건너 뛰어 O(n)이 될 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/001b6bfe-6c39-48f9-93b3-8e9aab33e4c1/Untitled.png)

빅오 표기법은 시간 복잡도 외에도 공간 복잡도를 표현하는데 널리 쓰인다. 인풋과 스텝의 상관관계에 집중하기 떄문에 상수를 신경쓰지 않는다. 알고리즘을 설명한다.

알고리즘은  **"시간과 공간이 트레이드오프 관계이다"** (트레이드 오프 : 하나가 증가하면 다른 하나는 감소한다.)

즉, 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다는 것이다

## 4정렬 알고리즘

**sorting** 

뭔가를 정리하는 것(ex 큰 수에서 작은 수로 정렬)
 

**Bubble Sort(버블 정렬)**

버블 정렬은 매번 연속된 두개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법이다.

오름차순으로 정렬하고자 할 경우, 비교시마다 큰 값이 뒤로 이동하여, 1바퀴 돌시 가장 큰 값이 맨 뒤에 저장된다.

로직

1.삽입 정렬은 두 번쨰 인덱스부터 시작한다. 현재 인덱스 값과, 바로 이전의 인덱스 값을 비교한다.

2.만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.

3.현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.

4.이를 반복한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b8f83d3-3ead-443c-9832-f64a58594dc6/Untitled.png)

 시간복잡도 

 O(n^2)

큰 값이 계속 오른쪽으로 이동한다.

**장점** 

구현이 간단하다.

데이터를 하나씩 비교하기 떄문에 정밀한 비교가 가능하다.

**단점**

데이터를 하나씩 비교하기 때문에 비교 횟수가 많아지므로 시간이 오래 걸린다.

**Selection Sort(선택 정렬)**

현재 위치에 들어갈 값을 찾아 정렬하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 딸 최소 선택 정렬와 최대 선택 정려로 구분할 수 있다.최소 선택 정렬은 오름차순으로, 최대 선택 정렬은 내림차수능로 정렬될 것이다.

기본로직 

1.정렬 되지 않은 인덱스의 맨 앞에서 부터 배열값 중 가장 작은 값을 찾아간다.

2.가장 작은 값을 찾으면 그 값을 현재 인덱스의 값과 바꾸준다.

3.다음 인덱스에서 이 과정을 반복한다.

시간복잡도 

 O(n^2)

**👍  장점**

입력으로 들어오는 배열의 원소가 정렬되어있을수록 속도가 빠르다.

정렬된 값은 교환이 일어나지 않는다.

**👎  단점**

▶️ 삽입을 구현해야 하므로 속도가 자료구조의 영향을 많이 받는다.

▶️ 입력으로 들어오는 배열이 역순으로 정렬된 경우 성능이 굉장히 좋지 않다.

**Insertion Sort(삽입 정렬)**

삽입 정렬은 현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 그 위치에 삽입하는 배열 알고리즘이다.

Insertion Sort는 **2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입**
 하여 정렬하는 알고리즘이다.

다음에는 3번쨰 원소부터 사이클이 돌아간다.

시간복잡도 

 O(n^2)

정렬 알고리즘 

삽입,선택 정렬은 작은 DB기준으로 훌륭한 알고리즘이다.

## 5.Hash Table

**Hash Table**

Key Value System을 이용하여 자료를 정리한다.(ex 사전)

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이다. 해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.

 

시간복잡도는 O(1)

key를 가져다가 해시함수에 넣고, 해시함수가 준 숫자를 value에 저장한다.

프로그래밍에 이미 해시 테이블이 있다.

 

**해시 충돌**

각기 다른 Key에 대하여 해시함수가 동일한 숫자를 준 경우

충돌에 의한 문제를 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing) 크게 2가지로 해결하고 있다.

**해결법**

1.****분리 연결법(Separate Chaining)**** 

Separate Chaining이란 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다.

이러한 Chaining 방식은 해시 테이블의 확장이 필요없고 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다. 하지만 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.

**2.개방 주소법(Open Addressing)** 

Open Addressing이란 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다. 

Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.

Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.

Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

데이터프레임에서 특정한 데이터만 골라내는 것을 인덱싱(indexing)이라고 한다
